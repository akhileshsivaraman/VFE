library(phytools)
data("anoletree")
View(anoletree)
plotTree(anoletree)
svl <- read.csv("http://www.phytools.org/eqg2015/data/svl.csv", row.names = T)
svl <- read.csv("http://www.phytools.org/eqg2015/data/svl.csv", row.names = 1)
View(svl)
svl <- as.matrix(svl)[,1]
names(svl)
# estimate ancestral states
fit <- fastAnc(anoletree, svl, vars = T, CI = T)
tree <- geiger::treedata(anoletree, svl)
# estimate ancestral states
fit <- fastAnc(anoletree, svl, vars = T, CI = T)
# estimate ancestral states
svl1 <- svl[1:82]
fit <- fastAnc(anoletree, svl1, vars = T, CI = T)
library(ape)
library(phytools)
install.packages("diversitree")
library(diversitree)
data("anoletree")
x <- getStates(anoletree, "tips")
View(anoletree)
anoletree[["maps"]]
anoletree[["node.states"]]
x
rmtree(anoletree)
tree <- anoletree
rm(anoletree)
tree
plot(tree,
type = "fan")
plot(tree,
type = "fan", fsize = 0.8)
plot(tree,
type = "fan", fsize = 0.8, ftype = "i")
plot(tree, type = "fan", fsize = 0.8, ftype = "i")
par(mar=c(0,0,0,0))
plot(tree, type = "fan", fsize = 0.8, ftype = "i")
plot.phylo(tree, "cladogram")
plot.phylo(tree, "phylogram")
plotTree(tree, type = "fan", fsize = 0.8, ftype = i)
plotTree(tree, type = "fan", fsize = 0.8, ftype = "i")
plotTree(tree)
plotTree(tree, type = "fan", fsize = 1, ftype = "i")
plotTree(tree)
cols <- setNames(palette()[1:length(unique(x))], sort(unique(x)))
tiplabels(pie = to.matrix(x, sort(unique(x))), piecol = cols, cex=0.3)
plot.phylo(tree, offset = 0.2)
plot.phylo(tree, label.offset = 0.4)
plot.phylo(tree, label.offset = 0.4)
cols <- setNames(palette()[1:length(unique(x))], sort(unique(x)))
tiplabels(pie = to.matrix(x, sort(unique(x))), piecol = cols, cex=0.3)
plot.phylo(tree, label.offset = 0.4, cex = 0.8)
cols <- setNames(palette()[1:length(unique(x))], sort(unique(x)))
tiplabels(pie = to.matrix(x, sort(unique(x))), piecol = cols, cex=0.3)
add.simmap.legend(colors = cols, prompt = F,
x = 0.9*par()$usr[1],
y = -max(nodeHeights(tree)), fsize = 0.8)
add.simmap.legend(colors = cols)
fitER <- ace(x, tree, model = "ER", type = "discrete")
fitER
round(fitER$lik.anc, 3)
plot.phylo(tree, label.offset = 0.4, cex = 0.8)
nodelabels(node = 1:tree$Nnode+Ntip(tree),
pie = fitER$lik.anc, piecol = cols, cex = 0.5)
tiplabels(pie = to.matrix(x, sort(unique(x))), piecol = cols, cex = 0.3)
par(mfrow = c(1,1))
plot.phylo(tree, label.offset = 0.4, cex = 0.8)
par(mfrow = c(0,1))
par(mfrow = c(1,1))
plot.phylo(tree, label.offset = 0.4, cex = 0.8)
nodelabels(node = 1:tree$Nnode+Ntip(tree),
pie = fitER$lik.anc, piecol = cols, cex = 0.5)
tiplabels(pie = to.matrix(x, sort(unique(x))), piecol = cols, cex = 0.3)
plot.phylo(tree, label.offset = 0.4, cex = 0.8, type = "cladogram")
plot.phylo(tree, label.offset = 0.4, cex = 0.8, type = "cladogram", use.edge.length = F)
nodelabels(node = 1:tree$Nnode+Ntip(tree),
pie = fitER$lik.anc, piecol = cols, cex = 0.5)
tiplabels(pie = to.matrix(x, sort(unique(x))), piecol = cols, cex = 0.3)
par(mfcol = c(1,1))
plot.phylo(tree, label.offset = 0.4, cex = 0.8, type = "cladogram", use.edge.length = F)
nodelabels(node = 1:tree$Nnode+Ntip(tree),
pie = fitER$lik.anc, piecol = cols, cex = 0.5)
tiplabels(pie = to.matrix(x, sort(unique(x))), piecol = cols, cex = 0.3)
# MCMC model
mtree <- make.simmap(tree, x, model = "ER")
plot.phylo(mtree, type = "radial")
plot.phylo(mtree, type = "phylogram")
plot.phylo(mtree, type = "phylogram", cols)
plot.phylo(mtree, edge.color = cols, type = "phylogram")
mtrees <- make.simmap(tree, x, model = "ER", nsim = 100)
par(mfrow = c(10,10))
null <- sapply(mtrees, plot, colours = cols)
null <- sapply(mtrees, plot, col = cols)
pd <- summary(mtrees, plot = F)
pd
plot(pd, fsize = 0.6, ftype = "i")
par(mfrow = c(1,1))
pd <- summary(mtrees, plot = F)
plot(pd, fsize = 0.6, ftype = "i")
plot(mtrees[[1]], col = cols)
nodelabels(pie = pd$ace, piecol = cols, cex = 0.5)
library(phytools)
source("sim.history.R")
library(ape)
tree <- rbdtree(b=1, d=0, Tmax = log(12.5))
q <- matrix(c(-1,1,1,-1),2,2)
View(q)
View(tree)
mtree <- sim.history(tree, q)
plotSimmap(mtree)
View(mtree)
View(tree)
View(mtree)
library(auteur)
install.packages("~/Downloads/auteur_0.11.0612.tar", repos = NULL)
install.packages("Imperial/UEBS/Papers/auteur/", repos = NULL, type = "source")
# install.packages("Imperial/UEBS/Papers/auteur/", repos = NULL, type = "source")
library(auteur)
n = 24
while (1) {
phy=prunelastsplit(birthdeath.tree(b=1,d=0,taxa.stop=n+1))
phy$tip.label=paste("sp",1:n,sep="")
rphy=reorder(phy,"pruningwise")
# find an internal edge
anc=get.desc.of.node(Ntip(phy)+1,phy)
branches=phy$edge[,2]
branches=branches[branches>Ntip(phy) & branches!=anc]
branch=branches[sample(1:length(branches),1)]
desc=get.descendants.of.node(branch,phy)
if(length(desc)>=4) break()
}
View(phy)
rphy = phy
rphy$edge.length[match(desc,phy$edge[,2])]=phy$edge.length[match(desc,phy$edge[,2])]*64
e=numeric(nrow(phy$edge))
e[match(c(branch,desc),phy$edge[,2])]=1
cols=c("red","gray")
dev.new()
plot(phy,edge.col=ifelse(e==1,cols[1],cols[2]), edge.width=2)
mtext("expected pattern of rates")
#############
## simulate data on the 'rate-shifted' tree
dat=rTraitCont(phy=rphy, model="BM", sigma=sqrt(0.1))
## run two short reversible-jump Markov chains
r=paste(sample(letters,9,replace=TRUE),collapse="")
lapply(1:2, function(x) rjmcmc.bm(phy=phy, dat=dat, ngen=10000, sample.freq=10, prob.mergesplit=0.1, simplestart=TRUE, prop.width=1, fileBase=paste(r,x,sep=".")))
# collect directories
dirs=dir("./",pattern=paste("BM",r,sep=".")) # rjmcmc results have been stored in documents (the wd in this case)
pool.rjmcmcsamples(base.dirs=dirs, lab=r)
# view rda file content
load(paste(paste(r,"combined.rjmcmc",sep="."),paste(r,"posteriorsamples.rda",sep="."),sep="/"))
print(head(posteriorsamples$rates))
print(head(posteriorsamples$rate.shifts))
## plot Markov sampled rates
dev.new()
shifts.plot(phy=phy, base.dir=paste(r,"combined.rjmcmc",sep="."), burnin=0.5, legend=TRUE, edge.width=2)
## plot Markov sampled rates
plot.new()
shifts.plot(phy=phy, base.dir=paste(r,"combined.rjmcmc",sep="."), burnin=0.5, legend=TRUE, edge.width=2)
# clean-up: unlink those directories
unlink(dir(pattern=paste(r)),recursive=TRUE)
##### auteur example #####
# install.packages("Imperial/UEBS/Papers/auteur/", repos = NULL, type = "source")
library(auteur)
n = 24
while (1) {
phy=prunelastsplit(birthdeath.tree(b=1,d=0,taxa.stop=n+1))
phy$tip.label=paste("sp",1:n,sep="")
rphy=reorder(phy,"pruningwise")
# find an internal edge
anc=get.desc.of.node(Ntip(phy)+1,phy)
branches=phy$edge[,2]
branches=branches[branches>Ntip(phy) & branches!=anc]
branch=branches[sample(1:length(branches),1)]
desc=get.descendants.of.node(branch,phy)
if(length(desc)>=4) break()
}
rphy = phy
rphy$edge.length[match(desc,phy$edge[,2])]=phy$edge.length[match(desc,phy$edge[,2])]*64
e=numeric(nrow(phy$edge))
e[match(c(branch,desc),phy$edge[,2])]=1
cols=c("red","gray")
plot(phy,edge.col=ifelse(e==1,cols[1],cols[2]), edge.width=2)
mtext("expected pattern of rates")
## simulate data on the 'rate-shifted' tree
dat=rTraitCont(phy=rphy, model="BM", sigma=sqrt(0.1)) # use to simulate PCA data
## run two short reversible-jump Markov chains
r=paste(sample(letters,9,replace=TRUE),collapse="")
lapply(1:2, function(x) rjmcmc.bm(phy=phy, dat=dat, ngen=10000, sample.freq=10, prob.mergesplit=0.1, simplestart=TRUE, prop.width=1, fileBase=paste(r,x,sep=".")))
pool.rjmcmcsamples(base.dirs=dirs, lab=r)
# collect directories
dirs=dir("./",pattern=paste("BM",r,sep=".")) # rjmcmc results have been stored in documents (the wd in this case)
pool.rjmcmcsamples(base.dirs=dirs, lab=r)
# view rda file content
load(paste(paste(r,"combined.rjmcmc",sep="."),paste(r,"posteriorsamples.rda",sep="."),sep="/"))
print(head(posteriorsamples$rates))
print(head(posteriorsamples$rate.shifts))
## plot Markov sampled rates
plot.new()
shifts.plot(phy=phy, base.dir=paste(r,"combined.rjmcmc",sep="."), burnin=0.5, legend=TRUE, edge.width=2)
geiger::rjmcmc.bm(phy=phy, dat=dat, ngen=10000, sample.freq=10, prob.mergesplit=0.1, simplestart=TRUE, prop.width=1, fileBase=paste(r,x,sep="."))
geiger::rjmcmc.bm(phy=phy, dat=dat, ngen=10000, sample.freq=10, prob.mergesplit=0.1, simplestart=TRUE, prop.width=1)
res <- load.rjmcmc(x = "jump-relaxedBM.result/")
shifts.plot(phy = phy, base.dir = "jump-relaxedBM.result/", legend = T)
paste(r,"combined.rjmcmc",sep=".")
shifts.plot(phy = phy, base.dir = "dvzqemktl.combined.rjmcmc", legend = T)
shifts.plot(phy = phy, base.dir = "jump-relaxedBM.result", legend = T)
plot(x = res, par = "shifts", burnin = 0.25, legend = T)
res1 <- load.rjmcmc("dvzqemktl.combined.rjmcmc/")
res1 <- load.rjmcmc("BM.dvzqemktl.1.parameters/")
plot(x = res, par = "jumps", burnin = 0.25, legend = T)
# clean-up: unlink those directories
unlink(dir(pattern=paste(r)),recursive=TRUE)
log <- res$log
View(log)
library(phytools)
library(geiger)
setwd("~/Documents/Imperial/UEBS/2.MS-Ecomorphology_lower_jaw/Data _ Analyses")
tree <- read.nexus("Adam_ML_SharkTree.nex.txt")
data <- read.table("N=153 spp PC1 dietcode MCL averaged by spp NA diet pruned.txt", header=T,row.names=1)
View(data)
newtree <- treedata(tree, data)
#Function to transform ancestral states reconstruction to a SIMMAP like tree (to be added to mvMORPH)
paintAllTree <- function(tree, ancestral, tips){
names_grps <- colnames(ancestral$lik.anc)
statesNodes <- names_grps[apply(ancestral$lik.anc, 1, which.max)]
combined = as.character(c(tips, statesNodes))
treebis=tree
for(i in sort(tree$edge[,2])){
treebis <- paintBranches(treebis, i, combined[i], anc.state=combined[Ntip(tree)+1])
}
return(treebis)
}
install.packages("mvMORPH")
library(mvMORPH)
pc1 <- newtree$data[,2]
pc1 <- as.numeric(pc1)
names(pc1) <- rownames(newtree$data)
s <- ace(pc1, newtree$phy, model = "ER", type = "continuous")
View(s)
# plot tree states
plotTree(newtree$phy, type = "fan", fsize = 0.3, ftype = "i")
nodelabels(node = 1:newtree$phy$Nnode+Ntip(newtree$phy),
pie = s$ace, cex = 0.2)
View(data)
prey <- newtree$data[,3]
prey <- as.numeric(prey)
names(prey) <- rownames(newtree$data)
# ancestral state reconstruction
s <- ace(prey, newtree$phy, model = "ER", type = "discrete")
# plot tree states
plotTree(newtree$phy, type = "fan", fsize = 0.3, ftype = "i")
nodelabels(node = 1:newtree$phy$Nnode+Ntip(newtree$phy),
pie = s$ace, cex = 0.2)
nodelabels(node = 1:newtree$phy$Nnode+Ntip(newtree$phy),
pie = s$ace, cex = 0.4)
View(s)
# transform to simmap
tree2test <- paintAllTree(newtree$phy, s, prey)
View(tree2test)
cols <- rainbow(ncol(tree2test$mapped.edge))
names(cols) <- colnames(tree2test$mapped.edge)
plot(tree2test, col=cols)
add.simmap.legend(colors = cols, prompt = T, fsize=0.8)
plotShifts <-
function(phylo, chain, burnin=1000, ...){
#require(fields)
args <- list(...)
# options
if(is.null(args[["fun"]])) args$fun <- mean
if(is.null(args[["show.tip.label"]])) args$show.tip.label <- TRUE
if(is.null(args[["horizontal"]])) args$horizontal <- TRUE
if(is.null(args[["color"]])) args$color <- c("blue", "red")
if(is.null(args[["scale"]])) args$scale <- FALSE
if(is.null(args[["log"]])) args$log <- FALSE
if(is.null(args[["palette"]])) args$palette <- FALSE
if(is.null(args[["main"]])) args$main <- NULL
if(is.null(args[["cex"]])) args$cex <- 0.8
if(is.null(args[["width"]])) args$width <- 1
if(inherits(chain, "mcmc")){
tot <- nrow(chain)
if(burnin>tot) stop("Error! the burnin value is higher than the chain length")
chain <- chain[c(burnin:tot),-1]
meanRate <- apply(chain, 2, args$fun)
if(args$log==TRUE) meanRate <- log(meanRate)
}else{
meanRate <- chain
if(args$log==TRUE) meanRate <- log(chain)
}
#check the order of the tree; prunning algorithm use "postorder"
#if(attr(phylo,"order")!="postorder") phylo <- reorder.phylo(phylo, "postorder")
#colors mapping
if(any(args$palette==FALSE)){
Colors = colorRampPalette(args$color)( 100 )
}else{
Colors = args$palette
}
#0 index induce error I scale it between 1 and 100
linScale <- function(x, from, to) round( (x - min(x)) / max(x - min(x)) * (to - from) + from)
col <- linScale(meanRate, from=1, to=100)
if(args$scale==TRUE){
phylo$edge.length <- phylo$edge.length*meanRate
}
plot(phylo, edge.color = Colors[col], show.tip.label = args$show.tip.label, main = args$main, cex = args$cex, edge.width = args$width)
image.plot(z = as.matrix(meanRate),col = Colors,
legend.only = T, horizontal = args$horizontal)
}
res <- load.rjmcmc("BM.result/")
res1 <- plot(res, par = "shift", type = "fan")
View(res)
log <- res$log
View(log)
rates <- res$rates
plotShifts(reorder(newtree$phy,"cladewise") , chain=rates, color=c("blue","light blue", "green", "yellow", "orange", "dark orange", "red"))
str(res)
library(coda)
mcmc(res$log)
plot(mcmc(res$log[,8]))
plot(mcmc(res$log[,]))
effectiveSize(mcmc(res$log))
##### rjmcmcm.bm example #####
# https://rdrr.io/cran/geiger/man/rjmcmc.bm.html
library(phytools)
library(geiger)
library(ape)
library(coda)
setwd("~/Documents/Imperial/UEBS/Code")
ps <- load.rjmcmc("relaxedBM.result/")
plot(x = ps, par = "shifts", burnin = 0.25, legend = T, show.tip = T)
View(ps)
log <- ps$log
View(log)
a <- col2rgb(log[,3])
b <- col2rgb(log[,4])
plot(x = ps, par = "jumps", burnin = 0.25, legend = T, show.tip = T)
